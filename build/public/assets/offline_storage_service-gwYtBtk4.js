var g=Object.defineProperty;var b=(i,e,t)=>e in i?g(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var p=(i,e,t)=>b(i,typeof e!="symbol"?e+"":e,t);class S{constructor(){p(this,"dbName","AbsensiDB");p(this,"version",1);p(this,"isSupported",!1);this.isSupported=typeof window<"u"&&"indexedDB"in window}async init(){if(!this.isSupported)throw new Error("IndexedDB is not supported in this environment");return new Promise((e,t)=>{const r=indexedDB.open(this.dbName,this.version);r.onerror=()=>t(r.error),r.onsuccess=()=>e(r.result),r.onupgradeneeded=a=>{const n=a.target.result;n.objectStoreNames.contains("absensi")||n.createObjectStore("absensi",{keyPath:"id",autoIncrement:!0})}})}async saveAbsensi(e){if(!this.isSupported){console.warn("IndexedDB not supported, skipping offline storage");return}try{const t=await this.init();return new Promise((r,a)=>{const n=t.transaction(["absensi"],"readwrite"),s=n.objectStore("absensi");e.forEach(d=>{const o={...d,syncStatus:"pending",createdAt:new Date().toISOString()};s.add(o)}),n.oncomplete=()=>{t.close(),r()},n.onerror=()=>{t.close(),a(n.error)}})}catch(t){throw console.error("Error saving to offline storage:",t),t}}async getPendingAbsensi(){if(!this.isSupported)return[];try{const e=await this.init();return new Promise((t,r)=>{const s=e.transaction(["absensi"],"readonly").objectStore("absensi").getAll();s.onsuccess=()=>{const o=(s.result||[]).filter(c=>c.syncStatus==="pending");e.close(),t(o)},s.onerror=()=>{e.close(),r(s.error)}})}catch(e){return console.error("Error getting pending absensi:",e),[]}}async markAsSynced(e){if(this.isSupported)try{const t=await this.init();return new Promise((r,a)=>{const s=t.transaction(["absensi"],"readwrite").objectStore("absensi");let d=0;const o=e.length;if(o===0){t.close(),r();return}const c=()=>{d++,d===o&&(t.close(),r())};e.forEach(u=>{const l=s.get(u);l.onsuccess=()=>{const h=l.result;if(h){h.syncStatus="synced";const f=s.put(h);f.onsuccess=c,f.onerror=()=>{c()}}else c()},l.onerror=()=>{c()}})})}catch(t){throw console.error("Error marking as synced:",t),t}}async clearSyncedData(){if(this.isSupported)try{const e=await this.init();return new Promise((t,r)=>{const n=e.transaction(["absensi"],"readwrite").objectStore("absensi"),s=n.getAll();s.onsuccess=()=>{const o=(s.result||[]).filter(u=>u.syncStatus==="synced");if(o.length===0){e.close(),t();return}let c=0;o.forEach(u=>{const l=n.delete(u.id);l.onsuccess=()=>{c++,c===o.length&&(e.close(),t())},l.onerror=()=>{c++,c===o.length&&(e.close(),t())}}),r(o)},s.onerror=()=>{e.close(),r(s.error)}})}catch(e){throw console.error("Error clearing synced data:",e),e}}isStorageSupported(){return this.isSupported}}const y=new S;export{y as o};
