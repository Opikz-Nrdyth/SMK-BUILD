var f=Object.defineProperty;var g=(c,e,t)=>e in c?f(c,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):c[e]=t;var p=(c,e,t)=>g(c,typeof e!="symbol"?e+"":e,t);class b{constructor(){p(this,"dbName","AbsensiWaliKelasDB");p(this,"version",1);p(this,"isSupported",!1);this.isSupported=typeof window<"u"&&"indexedDB"in window}async init(){if(!this.isSupported)throw new Error("IndexedDB is not supported in this environment");return new Promise((e,t)=>{const r=indexedDB.open(this.dbName,this.version);r.onerror=()=>t(r.error),r.onsuccess=()=>e(r.result),r.onupgradeneeded=a=>{const n=a.target.result;n.objectStoreNames.contains("absensi_wali")||n.createObjectStore("absensi_wali",{keyPath:"id",autoIncrement:!0})}})}async saveAbsensi(e){if(!this.isSupported){console.warn("IndexedDB not supported, skipping offline storage");return}try{const t=await this.init();return new Promise((r,a)=>{const n=t.transaction(["absensi_wali"],"readwrite"),s=n.objectStore("absensi_wali");e.forEach(d=>{const o={...d,syncStatus:"pending",createdAt:new Date().toISOString()};s.add(o)}),n.oncomplete=()=>{t.close(),r()},n.onerror=()=>{t.close(),a(n.error)}})}catch(t){throw console.error("Error saving to offline storage:",t),t}}async getPendingAbsensi(){if(!this.isSupported)return[];try{const e=await this.init();return new Promise((t,r)=>{const s=e.transaction(["absensi_wali"],"readonly").objectStore("absensi_wali").getAll();s.onsuccess=()=>{const o=(s.result||[]).filter(i=>i.syncStatus==="pending");e.close(),t(o)},s.onerror=()=>{e.close(),r(s.error)}})}catch(e){return console.error("Error getting pending absensi:",e),[]}}async markAsSynced(e){if(this.isSupported)try{const t=await this.init();return new Promise((r,a)=>{const s=t.transaction(["absensi_wali"],"readwrite").objectStore("absensi_wali");let d=0;const o=e.length;if(o===0){t.close(),r();return}const i=()=>{d++,d===o&&(t.close(),r())};e.forEach(u=>{const l=s.get(u);l.onsuccess=()=>{const w=l.result;if(w){w.syncStatus="synced";const h=s.put(w);h.onsuccess=i,h.onerror=()=>{i()}}else i()},l.onerror=()=>{i()}})})}catch(t){throw console.error("Error marking as synced:",t),t}}async clearSyncedData(){if(this.isSupported)try{const e=await this.init();return new Promise((t,r)=>{const n=e.transaction(["absensi_wali"],"readwrite").objectStore("absensi_wali"),s=n.getAll();s.onsuccess=()=>{const o=(s.result||[]).filter(u=>u.syncStatus==="synced");if(o.length===0){e.close(),t();return}let i=0;o.forEach(u=>{const l=n.delete(u.id);l.onsuccess=()=>{i++,i===o.length&&(e.close(),t())},l.onerror=()=>{i++,i===o.length&&(e.close(),t())}}),r(o)},s.onerror=()=>{e.close(),r(s.error)}})}catch(e){throw console.error("Error clearing synced data:",e),e}}isStorageSupported(){return this.isSupported}}const y=new b;export{y as o};
